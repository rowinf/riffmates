"""
This type stub file was generated by pyright.
"""

import threading
import unittest
from contextlib import contextmanager
from django.core.handlers.wsgi import WSGIHandler
from django.core.servers.basehttp import ThreadedWSGIServer, WSGIRequestHandler
from django.test.client import AsyncClient, Client
from django.test.utils import CaptureQueriesContext
from django.utils.functional import classproperty
from django.utils.version import PY310

logger = ...
__all__ = ("TestCase", "TransactionTestCase", "SimpleTestCase", "skipIfDBFeature", "skipUnlessDBFeature")
def to_list(value): # -> list[Any]:
    """Put value into a list if it's not already one."""
    ...

def assert_and_parse_html(self, html, user_msg, msg): # -> RootElement:
    ...

class _AssertNumQueriesContext(CaptureQueriesContext):
    def __init__(self, test_case, num, connection) -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> None:
        ...
    


class _AssertTemplateUsedContext:
    def __init__(self, test_case, template_name, msg_prefix=..., count=...) -> None:
        ...
    
    def on_template_render(self, sender, signal, template, context, **kwargs): # -> None:
        ...
    
    def test(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> None:
        ...
    


class _AssertTemplateNotUsedContext(_AssertTemplateUsedContext):
    def test(self): # -> None:
        ...
    


class DatabaseOperationForbidden(AssertionError):
    ...


class _DatabaseFailure:
    def __init__(self, wrapped, message) -> None:
        ...
    
    def __call__(self):
        ...
    


class _AssertFormErrorDeprecationHelper:
    @staticmethod
    def assertFormError(self, response, form, field, errors, msg_prefix=...): # -> None:
        """
        Search through all the rendered contexts of the `response` for a form named
        `form` then dispatch to the new assertFormError() using that instance.
        If multiple contexts contain the form, they're all checked in order and any
        failure will abort (this matches the old behavior).
        """
        ...
    
    @staticmethod
    def assertFormSetError(self, response, formset, form_index, field, errors, msg_prefix=...): # -> None:
        """
        Search for a formset named "formset" in the "response" and dispatch to
        the new assertFormSetError() using that instance. If the name is found
        in multiple contexts they're all checked in order and any failure will
        abort the test.
        """
        ...
    
    @classmethod
    def patch_signature(cls, new_method): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
        """
        Replace the decorated method with a new one that inspects the passed
        args/kwargs and dispatch to the old implementation (with deprecation
        warning) when it detects the old signature.
        """
        ...
    


class SimpleTestCase(unittest.TestCase):
    client_class = Client
    async_client_class = AsyncClient
    _overridden_settings = ...
    _modified_settings = ...
    databases = ...
    _disallowed_database_msg = ...
    _disallowed_connection_methods = ...
    @classmethod
    def setUpClass(cls): # -> None:
        ...
    
    def __call__(self, result=...): # -> None:
        """
        Wrapper around default __call__ method to perform common Django test
        set up. This means that user-defined Test Cases aren't required to
        include a call to super().setUp().
        """
        ...
    
    def debug(self): # -> None:
        """Perform the same as __call__(), without catching the exception."""
        ...
    
    def settings(self, **kwargs): # -> override_settings:
        """
        A context manager that temporarily sets a setting and reverts to the
        original value when exiting the context.
        """
        ...
    
    def modify_settings(self, **kwargs): # -> modify_settings:
        """
        A context manager that temporarily applies changes a list setting and
        reverts back to the original value when exiting the context.
        """
        ...
    
    def assertRedirects(self, response, expected_url, status_code=..., target_status_code=..., msg_prefix=..., fetch_redirect_response=...): # -> None:
        """
        Assert that a response redirected to a specific URL and that the
        redirect URL can be loaded.

        Won't work for external links since it uses the test client to do a
        request (use fetch_redirect_response=False to check such links without
        fetching them).
        """
        ...
    
    def assertURLEqual(self, url1, url2, msg_prefix=...): # -> None:
        """
        Assert that two URLs are the same, ignoring the order of query string
        parameters except for parameters with the same name.

        For example, /path/?x=1&y=2 is equal to /path/?y=2&x=1, but
        /path/?a=1&a=2 isn't equal to /path/?a=2&a=1.
        """
        ...
    
    def assertContains(self, response, text, count=..., status_code=..., msg_prefix=..., html=...): # -> None:
        """
        Assert that a response indicates that some content was retrieved
        successfully, (i.e., the HTTP status code was as expected) and that
        ``text`` occurs ``count`` times in the content of the response.
        If ``count`` is None, the count doesn't matter - the assertion is true
        if the text occurs at least once in the response.
        """
        ...
    
    def assertNotContains(self, response, text, status_code=..., msg_prefix=..., html=...): # -> None:
        """
        Assert that a response indicates that some content was retrieved
        successfully, (i.e., the HTTP status code was as expected) and that
        ``text`` doesn't occur in the content of the response.
        """
        ...
    
    @_AssertFormErrorDeprecationHelper.patch_signature
    def assertFormError(self, form, field, errors, msg_prefix=...): # -> None:
        """
        Assert that a field named "field" on the given form object has specific
        errors.

        errors can be either a single error message or a list of errors
        messages. Using errors=[] test that the field has no errors.

        You can pass field=None to check the form's non-field errors.
        """
        ...
    
    def assertFormsetError(self, *args, **kw): # -> None:
        ...
    
    @_AssertFormErrorDeprecationHelper.patch_signature
    def assertFormSetError(self, formset, form_index, field, errors, msg_prefix=...): # -> None:
        """
        Similar to assertFormError() but for formsets.

        Use form_index=None to check the formset's non-form errors (in that
        case, you must also use field=None).
        Otherwise use an integer to check the formset's n-th form for errors.

        Other parameters are the same as assertFormError().
        """
        ...
    
    def assertTemplateUsed(self, response=..., template_name=..., msg_prefix=..., count=...): # -> _AssertTemplateUsedContext | None:
        """
        Assert that the template with the provided name was used in rendering
        the response. Also usable as context manager.
        """
        ...
    
    def assertTemplateNotUsed(self, response=..., template_name=..., msg_prefix=...): # -> _AssertTemplateNotUsedContext | None:
        """
        Assert that the template with the provided name was NOT used in
        rendering the response. Also usable as context manager.
        """
        ...
    
    def assertRaisesMessage(self, expected_exception, expected_message, *args, **kwargs): # -> _GeneratorContextManager[Any] | None:
        """
        Assert that expected_message is found in the message of a raised
        exception.

        Args:
            expected_exception: Exception class expected to be raised.
            expected_message: expected error message string value.
            args: Function to be called and extra positional args.
            kwargs: Extra kwargs.
        """
        ...
    
    def assertWarnsMessage(self, expected_warning, expected_message, *args, **kwargs): # -> _GeneratorContextManager[Any] | None:
        """
        Same as assertRaisesMessage but for assertWarns() instead of
        assertRaises().
        """
        ...
    
    if not PY310:
        @contextmanager
        def assertNoLogs(self, logger, level=...): # -> Generator[None, Any, None]:
            """
            Assert no messages are logged on the logger, with at least the
            given level.
            """
            ...
        
    def assertFieldOutput(self, fieldclass, valid, invalid, field_args=..., field_kwargs=..., empty_value=...): # -> None:
        """
        Assert that a form field behaves correctly with various inputs.

        Args:
            fieldclass: the class of the field to be tested.
            valid: a dictionary mapping valid inputs to their expected
                    cleaned values.
            invalid: a dictionary mapping invalid inputs to one or more
                    raised error messages.
            field_args: the args passed to instantiate the field
            field_kwargs: the kwargs passed to instantiate the field
            empty_value: the expected clean output for inputs in empty_values
        """
        ...
    
    def assertHTMLEqual(self, html1, html2, msg=...): # -> None:
        """
        Assert that two HTML snippets are semantically the same.
        Whitespace in most cases is ignored, and attribute ordering is not
        significant. The arguments must be valid HTML.
        """
        ...
    
    def assertHTMLNotEqual(self, html1, html2, msg=...): # -> None:
        """Assert that two HTML snippets are not semantically equivalent."""
        ...
    
    def assertInHTML(self, needle, haystack, count=..., msg_prefix=...): # -> None:
        ...
    
    def assertJSONEqual(self, raw, expected_data, msg=...): # -> None:
        """
        Assert that the JSON fragments raw and expected_data are equal.
        Usual JSON non-significant whitespace rules apply as the heavyweight
        is delegated to the json library.
        """
        ...
    
    def assertJSONNotEqual(self, raw, expected_data, msg=...): # -> None:
        """
        Assert that the JSON fragments raw and expected_data are not equal.
        Usual JSON non-significant whitespace rules apply as the heavyweight
        is delegated to the json library.
        """
        ...
    
    def assertXMLEqual(self, xml1, xml2, msg=...): # -> None:
        """
        Assert that two XML snippets are semantically the same.
        Whitespace in most cases is ignored and attribute ordering is not
        significant. The arguments must be valid XML.
        """
        ...
    
    def assertXMLNotEqual(self, xml1, xml2, msg=...): # -> None:
        """
        Assert that two XML snippets are not semantically equivalent.
        Whitespace in most cases is ignored and attribute ordering is not
        significant. The arguments must be valid XML.
        """
        ...
    


class TransactionTestCase(SimpleTestCase):
    reset_sequences = ...
    available_apps = ...
    fixtures = ...
    databases = ...
    _disallowed_database_msg = ...
    serialized_rollback = ...
    def assertQuerysetEqual(self, *args, **kw): # -> None:
        ...
    
    def assertQuerySetEqual(self, qs, values, transform=..., ordered=..., msg=...): # -> None:
        ...
    
    def assertNumQueries(self, num, func=..., *args, using=..., **kwargs): # -> _AssertNumQueriesContext | None:
        ...
    


def connections_support_transactions(aliases=...): # -> bool:
    """
    Return whether or not all (or specified) connections support
    transactions.
    """
    ...

class TestData:
    """
    Descriptor to provide TestCase instance isolation for attributes assigned
    during the setUpTestData() phase.

    Allow safe alteration of objects assigned in setUpTestData() by test
    methods by exposing deep copies instead of the original objects.

    Objects are deep copied using a memo kept on the test case instance in
    order to maintain their original relationships.
    """
    memo_attr = ...
    def __init__(self, name, data) -> None:
        ...
    
    def get_memo(self, testcase): # -> Any | dict[Any, Any]:
        ...
    
    def __get__(self, instance, owner): # -> Any:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


class TestCase(TransactionTestCase):
    """
    Similar to TransactionTestCase, but use `transaction.atomic()` to achieve
    test isolation.

    In most situations, TestCase should be preferred to TransactionTestCase as
    it allows faster execution. However, there are some situations where using
    TransactionTestCase might be necessary (e.g. testing some transactional
    behavior).

    On database backends with no transaction support, TestCase behaves as
    TransactionTestCase.
    """
    @classmethod
    def setUpClass(cls): # -> None:
        ...
    
    @classmethod
    def tearDownClass(cls): # -> None:
        ...
    
    @classmethod
    def setUpTestData(cls): # -> None:
        """Load initial data for the TestCase."""
        ...
    
    @classmethod
    @contextmanager
    def captureOnCommitCallbacks(cls, *, using=..., execute=...): # -> Generator[list[Any], Any, None]:
        """Context manager to capture transaction.on_commit() callbacks."""
        ...
    


class CheckCondition:
    """Descriptor class for deferred condition checking."""
    def __init__(self, *conditions) -> None:
        ...
    
    def add_condition(self, condition, reason): # -> Self:
        ...
    
    def __get__(self, instance, cls=...): # -> bool:
        ...
    


def skipIfDBFeature(*features): # -> Callable[..., _Wrapped[Callable[..., Any], object, Callable[..., Any], object | Any] | type[TestCase]]:
    """Skip a test if a database has at least one of the named features."""
    ...

def skipUnlessDBFeature(*features): # -> Callable[..., _Wrapped[Callable[..., Any], object, Callable[..., Any], object | Any] | type[TestCase]]:
    """Skip a test unless a database has all the named features."""
    ...

def skipUnlessAnyDBFeature(*features): # -> Callable[..., _Wrapped[Callable[..., Any], object, Callable[..., Any], object | Any] | type[TestCase]]:
    """Skip a test unless a database has any of the named features."""
    ...

class QuietWSGIRequestHandler(WSGIRequestHandler):
    """
    A WSGIRequestHandler that doesn't log to standard output any of the
    requests received, so as to not clutter the test result output.
    """
    def log_message(*args): # -> None:
        ...
    


class FSFilesHandler(WSGIHandler):
    """
    WSGI middleware that intercepts calls to a directory, as defined by one of
    the *_ROOT settings, and serves those files, publishing them under *_URL.
    """
    def __init__(self, application) -> None:
        ...
    
    def file_path(self, url): # -> str:
        """Return the relative path to the file on disk for the given URL."""
        ...
    
    def get_response(self, request): # -> HttpResponse | HttpResponseNotModified | FileResponse | Coroutine[Any, Any, Any]:
        ...
    
    def serve(self, request): # -> HttpResponse | HttpResponseNotModified | FileResponse:
        ...
    
    def __call__(self, environ, start_response): # -> Coroutine[Any, Any, Any]:
        ...
    


class _StaticFilesHandler(FSFilesHandler):
    """
    Handler for serving static files. A private class that is meant to be used
    solely as a convenience by LiveServerThread.
    """
    def get_base_dir(self): # -> Any:
        ...
    
    def get_base_url(self): # -> Any:
        ...
    


class _MediaFilesHandler(FSFilesHandler):
    """
    Handler for serving the media files. A private class that is meant to be
    used solely as a convenience by LiveServerThread.
    """
    def get_base_dir(self): # -> Any:
        ...
    
    def get_base_url(self): # -> Any:
        ...
    


class LiveServerThread(threading.Thread):
    """Thread for running a live HTTP server while the tests are running."""
    server_class = ThreadedWSGIServer
    def __init__(self, host, static_handler, connections_override=..., port=...) -> None:
        ...
    
    def run(self): # -> None:
        """
        Set up the live server and databases, and then loop over handling
        HTTP requests.
        """
        ...
    
    def terminate(self): # -> None:
        ...
    


class LiveServerTestCase(TransactionTestCase):
    """
    Do basically the same as TransactionTestCase but also launch a live HTTP
    server in a separate thread so that the tests may use another testing
    framework, such as Selenium for example, instead of the built-in dummy
    client.
    It inherits from TransactionTestCase instead of TestCase because the
    threads don't share the same transactions (unless if using in-memory sqlite)
    and each thread needs to commit all their transactions so that the other
    thread can see the changes.
    """
    host = ...
    port = ...
    server_thread_class = LiveServerThread
    static_handler = _StaticFilesHandler
    @classproperty
    def live_server_url(cls): # -> str:
        ...
    
    @classproperty
    def allowed_host(cls): # -> str:
        ...
    
    @classmethod
    def setUpClass(cls): # -> None:
        ...
    


class SerializeMixin:
    """
    Enforce serialization of TestCases that share a common resource.

    Define a common 'lockfile' for each set of TestCases to serialize. This
    file must exist on the filesystem.

    Place it early in the MRO in order to isolate setUpClass()/tearDownClass().
    """
    lockfile = ...
    def __init_subclass__(cls, /, **kwargs): # -> None:
        ...
    
    @classmethod
    def setUpClass(cls): # -> None:
        ...
    


