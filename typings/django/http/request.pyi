"""
This type stub file was generated by pyright.
"""

from django.utils.datastructures import CaseInsensitiveMapping, MultiValueDict
from django.utils.functional import cached_property

RAISE_ERROR = ...
host_validation_re = ...
class UnreadablePostError(OSError):
    ...


class RawPostDataException(Exception):
    """
    You cannot access raw_post_data from a request that has
    multipart/* POST data if it has been accessed via POST,
    FILES, etc..
    """
    ...


class HttpRequest:
    """A basic HTTP request."""
    _encoding = ...
    _upload_handlers = ...
    def __init__(self) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @cached_property
    def headers(self): # -> HttpHeaders:
        ...
    
    @cached_property
    def accepted_types(self): # -> list[MediaType]:
        """Return a list of MediaType instances."""
        ...
    
    def accepts(self, media_type): # -> bool:
        ...
    
    def get_host(self): # -> str:
        """Return the HTTP host using the environment or request headers."""
        ...
    
    def get_port(self): # -> str:
        """Return the port number for the request as a string."""
        ...
    
    def get_full_path(self, force_append_slash=...): # -> str:
        ...
    
    def get_full_path_info(self, force_append_slash=...): # -> str:
        ...
    
    def get_signed_cookie(self, key, default=..., salt=..., max_age=...): # -> object | Any:
        """
        Attempt to return a signed cookie. If the signature fails or the
        cookie has expired, raise an exception, unless the `default` argument
        is provided,  in which case return that value.
        """
        ...
    
    def build_absolute_uri(self, location=...): # -> str:
        """
        Build an absolute URI from the location and the variables available in
        this request. If no ``location`` is specified, build the absolute URI
        using request.get_full_path(). If the location is absolute, convert it
        to an RFC 3987 compliant URI and return it. If location is relative or
        is scheme-relative (i.e., ``//example.com/``), urljoin() it to a base
        URL constructed from the request variables.
        """
        ...
    
    @property
    def scheme(self): # -> Literal['https', 'http']:
        ...
    
    def is_secure(self): # -> bool:
        ...
    
    @property
    def encoding(self): # -> None:
        ...
    
    @encoding.setter
    def encoding(self, val): # -> None:
        """
        Set the encoding used for GET/POST accesses. If the GET or POST
        dictionary has already been created, remove and recreate it on the
        next access (so that it is decoded correctly).
        """
        ...
    
    @property
    def upload_handlers(self): # -> list[Any]:
        ...
    
    @upload_handlers.setter
    def upload_handlers(self, upload_handlers): # -> None:
        ...
    
    def parse_file_upload(self, META, post_data): # -> tuple[QueryDict, MultiValueDict] | tuple[Any, Any]:
        """Return a tuple of (POST QueryDict, FILES MultiValueDict)."""
        ...
    
    @property
    def body(self):
        ...
    
    def close(self): # -> None:
        ...
    
    def read(self, *args, **kwargs): # -> bytes:
        ...
    
    def readline(self, *args, **kwargs): # -> bytes:
        ...
    
    def __iter__(self): # -> Iterator[bytes]:
        ...
    
    def readlines(self): # -> list[bytes]:
        ...
    


class HttpHeaders(CaseInsensitiveMapping):
    HTTP_PREFIX = ...
    UNPREFIXED_HEADERS = ...
    def __init__(self, environ) -> None:
        ...
    
    def __getitem__(self, key):
        """Allow header lookup using underscores in place of hyphens."""
        ...
    
    @classmethod
    def parse_header_name(cls, header): # -> None:
        ...
    
    @classmethod
    def to_wsgi_name(cls, header): # -> str:
        ...
    
    @classmethod
    def to_asgi_name(cls, header):
        ...
    
    @classmethod
    def to_wsgi_names(cls, headers): # -> dict[Any | str, Any]:
        ...
    
    @classmethod
    def to_asgi_names(cls, headers): # -> dict[Any, Any]:
        ...
    


class QueryDict(MultiValueDict):
    """
    A specialized MultiValueDict which represents a query string.

    A QueryDict can be used to represent GET or POST data. It subclasses
    MultiValueDict since keys in such data can be repeated, for instance
    in the data from a form with a <select multiple> field.

    By default QueryDicts are immutable, though the copy() method
    will always return a mutable copy.

    Both keys and values set on this class are converted from the given encoding
    (DEFAULT_CHARSET by default) to str.
    """
    _mutable = ...
    _encoding = ...
    def __init__(self, query_string=..., mutable=..., encoding=...) -> None:
        ...
    
    @classmethod
    def fromkeys(cls, iterable, value=..., mutable=..., encoding=...): # -> Self:
        """
        Return a new QueryDict with keys (may be repeated) from an iterable and
        values from value.
        """
        ...
    
    @property
    def encoding(self): # -> Any:
        ...
    
    @encoding.setter
    def encoding(self, value): # -> None:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __copy__(self): # -> Self:
        ...
    
    def __deepcopy__(self, memo): # -> Self:
        ...
    
    def setlist(self, key, list_): # -> None:
        ...
    
    def setlistdefault(self, key, default_list=...): # -> list[Any] | None:
        ...
    
    def appendlist(self, key, value): # -> None:
        ...
    
    def pop(self, key, *args):
        ...
    
    def popitem(self): # -> tuple[Any, Any]:
        ...
    
    def clear(self): # -> None:
        ...
    
    def setdefault(self, key, default=...): # -> list[Any]:
        ...
    
    def copy(self): # -> Self:
        """Return a mutable copy of this object."""
        ...
    
    def urlencode(self, safe=...): # -> LiteralString:
        """
        Return an encoded string of all query string arguments.

        `safe` specifies characters which don't require quoting, for example::

            >>> q = QueryDict(mutable=True)
            >>> q['next'] = '/a&b/'
            >>> q.urlencode()
            'next=%2Fa%26b%2F'
            >>> q.urlencode(safe='/')
            'next=/a%26b/'
        """
        ...
    


class MediaType:
    def __init__(self, media_type_raw_line) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def is_all_types(self):
        ...
    
    def match(self, other): # -> bool:
        ...
    


def bytes_to_text(s, encoding): # -> str:
    """
    Convert bytes objects to strings, using the given encoding. Illegally
    encoded input characters are replaced with Unicode "unknown" codepoint
    (\ufffd).

    Return any non-bytes objects without change.
    """
    ...

def split_domain_port(host): # -> tuple[Literal[''], Literal['']] | tuple[Any, Literal['']] | tuple[Any, Any | Literal['']]:
    """
    Return a (domain, port) tuple from a given host.

    Returned domain is lowercased. If the host is invalid, the domain will be
    empty.
    """
    ...

def validate_host(host, allowed_hosts): # -> bool:
    """
    Validate the given host for this site.

    Check that the host looks valid and matches a host or host pattern in the
    given list of ``allowed_hosts``. Any pattern beginning with a period
    matches a domain and all its subdomains (e.g. ``.example.com`` matches
    ``example.com`` and any subdomain), ``*`` matches anything, and anything
    else must match exactly.

    Note: This function assumes that the given host is lowercased and has
    already had the port, if any, stripped off.

    Return ``True`` for a valid host, ``False`` otherwise.
    """
    ...

def parse_accept_header(header): # -> list[MediaType]:
    ...

