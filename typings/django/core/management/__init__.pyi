"""
This type stub file was generated by pyright.
"""

import functools
import os
import pkgutil
import sys
import django
from argparse import _AppendConstAction, _CountAction, _StoreConstAction, _SubParsersAction
from collections import defaultdict
from difflib import get_close_matches
from importlib import import_module
from django.apps import apps
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.management.base import BaseCommand, CommandError, CommandParser, handle_default_options
from django.core.management.color import color_style
from django.utils import autoreload

def find_commands(management_dir): # -> list[str]:
    """
    Given a path to a management directory, return a list of all the command
    names that are available.
    """
    ...

def load_command_class(app_name, name): # -> Any:
    """
    Given a command name and an application name, return the Command
    class instance. Allow all errors raised by the import process
    (ImportError, AttributeError) to propagate.
    """
    ...

@functools.lru_cache(maxsize=None)
def get_commands(): # -> dict[str, str]:
    """
    Return a dictionary mapping command names to their callback applications.

    Look for a management.commands package in django.core, and in each
    installed application -- if a commands package exists, register all
    commands in that package.

    Core commands are always included. If a settings module has been
    specified, also include user-defined commands.

    The dictionary is in the format {command_name: app_name}. Key-value
    pairs from this dictionary can then be used in calls to
    load_command_class(app_name, command_name)

    The dictionary is cached on the first call and reused on subsequent
    calls.
    """
    ...

def call_command(command_name, *args, **options): # -> LiteralString | Any:
    """
    Call the given command, with the given options and args/kwargs.

    This is the primary API you should use for calling specific commands.

    `command_name` may be a string or a command object. Using a string is
    preferred unless the command object is required for further processing or
    testing.

    Some examples:
        call_command('migrate')
        call_command('shell', plain=True)
        call_command('sqlmigrate', 'myapp')

        from django.core.management.commands import flush
        cmd = flush.Command()
        call_command(cmd, verbosity=0, interactive=False)
        # Do something with cmd ...
    """
    ...

class ManagementUtility:
    """
    Encapsulate the logic of the django-admin and manage.py utilities.
    """
    def __init__(self, argv=...) -> None:
        ...
    
    def main_help_text(self, commands_only=...): # -> str:
        """Return the script's main help text, as a string."""
        ...
    
    def fetch_command(self, subcommand): # -> <subclass of str and BaseCommand> | Any:
        """
        Try to fetch the given subcommand, printing a message with the
        appropriate command called from the command line (usually
        "django-admin" or "manage.py") if it can't be found.
        """
        ...
    
    def autocomplete(self): # -> None:
        """
        Output completion suggestions for BASH.

        The output of this function is passed to BASH's `COMREPLY` variable and
        treated as completion suggestions. `COMREPLY` expects a space
        separated string as the result.

        The `COMP_WORDS` and `COMP_CWORD` BASH environment variables are used
        to get information about the cli input. Please refer to the BASH
        man-page for more information about this variables.

        Subcommand options are saved as pairs. A pair consists of
        the long option string (e.g. '--exclude') and a boolean
        value indicating if the option requires arguments. When printing to
        stdout, an equal sign is appended to options which require arguments.

        Note: If debugging this function, it is recommended to write the debug
        output in a separate file. Otherwise the debug output will be treated
        and formatted as potential completion suggestions.
        """
        ...
    
    def execute(self): # -> None:
        """
        Given the command-line arguments, figure out which subcommand is being
        run, create a parser appropriate to that command, and run it.
        """
        ...
    


def execute_from_command_line(argv=...): # -> None:
    """Run a ManagementUtility."""
    ...

