"""
This type stub file was generated by pyright.
"""

from django.db.models.utils import AltersData

class Deferred:
    def __repr__(self): # -> Literal['<Deferred field>']:
        ...
    
    def __str__(self) -> str:
        ...
    


DEFERRED = ...
def subclass_exception(name, bases, module, attached_to): # -> Any:
    """
    Create exception subclass. Used by ModelBase below.

    The exception is created in a way that allows it to be pickled, assuming
    that the returned exception class will be added as an attribute to the
    'attached_to' class.
    """
    ...

class ModelBase(type):
    """Metaclass for all models."""
    def __new__(cls, name, bases, attrs, **kwargs):
        ...
    
    def add_to_class(cls, name, value): # -> None:
        ...
    


class ModelStateFieldsCacheDescriptor:
    def __get__(self, instance, cls=...): # -> Self | dict[Any, Any]:
        ...
    


class ModelState:
    """Store model instance state."""
    db = ...
    adding = ...
    fields_cache = ...


class Model(AltersData, metaclass=ModelBase):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def from_db(cls, db, field_names, values): # -> Self:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __reduce__(self): # -> tuple[Callable[..., Any], tuple[tuple[Any, Any]], dict[str, Any]]:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        """Hook to allow choosing the attributes to pickle."""
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    pk = ...
    def get_deferred_fields(self): # -> set[Any]:
        """
        Return a set containing names of deferred fields for this instance.
        """
        ...
    
    def refresh_from_db(self, using=..., fields=...): # -> None:
        """
        Reload field values from the database.

        By default, the reloading happens from the database this instance was
        loaded from, or by the read router if this instance wasn't loaded from
        any database. The using parameter will override the default.

        Fields can be used to specify which fields to reload. The fields
        should be an iterable of field attnames. If fields is None, then
        all non-deferred fields are reloaded.

        When accessing deferred fields of an instance, the deferred loading
        of the field will call this method.
        """
        ...
    
    async def arefresh_from_db(self, using=..., fields=...): # -> None:
        ...
    
    def serializable_value(self, field_name): # -> Any:
        """
        Return the value of the field name for this instance. If the field is
        a foreign key, return the id value instead of the object. If there's
        no Field object with this name on the model, return the model
        attribute's value.

        Used to serialize a field's value (in the serializer, or form output,
        for example). Normally, you would just access the attribute directly
        and not use this method.
        """
        ...
    
    def save(self, force_insert=..., force_update=..., using=..., update_fields=...): # -> None:
        """
        Save the current instance. Override this in a subclass if you want to
        control the saving process.

        The 'force_insert' and 'force_update' parameters can be used to insist
        that the "save" must be an SQL insert or update (or equivalent for
        non-SQL backends), respectively. Normally, they should not be set.
        """
        ...
    
    async def asave(self, force_insert=..., force_update=..., using=..., update_fields=...): # -> None:
        ...
    
    def save_base(self, raw=..., force_insert=..., force_update=..., using=..., update_fields=...): # -> None:
        """
        Handle the parts of saving which should be done only once per save,
        yet need to be done in raw saves, too. This includes some sanity
        checks and signal sending.

        The 'raw' argument is telling save_base not to save any parent
        models and not to do any changes to the values before save. This
        is used by fixture loading.
        """
        ...
    
    def delete(self, using=..., keep_parents=...): # -> tuple[Any | int, dict[Any, Any | int]] | tuple[int, dict[Any, int]]:
        ...
    
    async def adelete(self, using=..., keep_parents=...): # -> tuple[Any | int, dict[Any, Any | int]] | tuple[int, dict[Any, int]]:
        ...
    
    def prepare_database_save(self, field): # -> Any:
        ...
    
    def clean(self): # -> None:
        """
        Hook for doing any extra model-wide validation after clean() has been
        called on every field by self.clean_fields. Any ValidationError raised
        by this method will not be associated with a particular field; it will
        have a special-case association with the field defined by NON_FIELD_ERRORS.
        """
        ...
    
    def validate_unique(self, exclude=...): # -> None:
        """
        Check unique constraints on the model and raise ValidationError if any
        failed.
        """
        ...
    
    def date_error_message(self, lookup_type, field_name, unique_for): # -> ValidationError:
        ...
    
    def unique_error_message(self, model_class, unique_check): # -> ValidationError:
        ...
    
    def get_constraints(self): # -> list[tuple[type[Self], Any]]:
        ...
    
    def validate_constraints(self, exclude=...): # -> None:
        ...
    
    def full_clean(self, exclude=..., validate_unique=..., validate_constraints=...): # -> None:
        """
        Call clean_fields(), clean(), validate_unique(), and
        validate_constraints() on the model. Raise a ValidationError for any
        errors that occur.
        """
        ...
    
    def clean_fields(self, exclude=...): # -> None:
        """
        Clean all fields and raise a ValidationError containing a dict
        of all validation errors if any occur.
        """
        ...
    
    @classmethod
    def check(cls, **kwargs): # -> list[Any]:
        ...
    


def method_set_order(self, ordered_obj, id_list, using=...): # -> None:
    ...

def method_get_order(self, ordered_obj):
    ...

def make_foreign_order_accessors(model, related_model): # -> None:
    ...

def model_unpickle(model_id):
    """Used to unpickle Model subclasses with deferred fields."""
    ...

